# A gotcha

When you're plumbing, you sometimes run into silly things

```{figure} ./../static/img/dafnybench-inspect-1.png
:name: fig-celebratory
:alt: celebrate good times

A language model is so excited that it solved the task that it passes its celebratory message into the proof checker. There's an (american) football metaphor about dancing in the touchdown zone somewhere.
```

## Extraction Strategy v2

### [ ] TODO: audit this, as an LLM wrote it

The figure above shows a real problem we encountered: after the agent successfully verifies code, it sometimes generates a celebratory message like "Perfect! The code now verifies successfully!" without a code block. Our initial extraction logic (`extract_code_v1`) simply grabbed the last code block from the final completion—which worked great until there was no code block in that final message.

The naive approach looked like this:

```{literalinclude} ../../evals/src/evals/dafnybench/inspect_ai/utils.py
:language: python
:caption: Buggy extraction (v1) - only looks at final completion
:linenos:
:start-at: def extract_code_v1
:end-before: def extract_code_v2
```

When the agent outputs "Great! It worked!" without code, `extract_code_v1` fails to find any code blocks. The scorer then tries to verify this celebration text as Dafny code, which obviously fails—turning a successful verification into a recorded failure.

The fix is **backtracking through message history**. Instead of only looking at the final completion, we walk backwards through all assistant messages until we find one containing code:

```{literalinclude} ../../evals/src/evals/dafnybench/inspect_ai/utils.py
:language: python
:caption: Fixed extraction (v2) - backtracks through message history
:linenos:
:start-at: def extract_code_v2
:end-before: def extract_code(
```

This handles the celebration problem elegantly: if the current message has no code, we skip it and check the previous message. We eventually find the most recent code the agent actually generated.

You can switch between strategies using the `extraction_strategy` parameter in the task definition:

```{literalinclude} ../../evals/src/evals/dafnybench/inspect_ai/__init__.py
:language: python
:caption: Configuring extraction strategy in task definition
:linenos:
:start-at: def dafnybench_task(
:end-at: extraction_strategy: ExtractionStrategy
```

We keep v1 available for pedagogical purposes—it demonstrates a real bug you might encounter when building verification agents. The unified interface lives in `utils.py:82-120`, dispatching to the appropriate implementation based on the `ExtractionStrategy` enum.

This pattern—searching backwards through conversation history—is useful whenever you have tool-calling loops where the final message might not contain the information you need. The verifier acts as a sensor providing feedback, and the agent's response to good news ("it worked!") can omit the actual artifact you're evaluating.

