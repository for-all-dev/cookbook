# The touchdown dance

When you're plumbing, you sometimes run into silly things

```{figure} ./../static/img/dafnybench-inspect-1.png
:name: fig-celebratory
:alt: celebrate good times

A language model is so excited that it solved the task that it passes its celebratory message into the proof checker. There's an (american) football metaphor about dancing in the touchdown zone somewhere.
```

## Extraction Strategy v2

After the agent successfully verifies code, it sometimes generates a celebratory message like "Perfect! The code now verifies successfully!" without a code block. Our initial extraction logic (`extract_code_v1`) simply grabbed the last code block from the final completion, which worked great until there was no code block in that final message.

### TODO: what we really want this chapter to be about is increased gracefulness of extracting code from responses. how to link it to your intuitions about error handling. 

The naive approach looked like this:

```{literalinclude} ../../evals/src/evals/dafnybench/inspect_ai/utils.py
:language: python
:caption: Buggy extraction (v1) - only looks at final completion
:linenos:
:start-at: def extract_code_v1
:end-before: def extract_code_v2
```

When the agent outputs "Great! It worked!" without code, `extract_code_v1` fails to find any code blocks. The scorer then tries to verify this touchdown dance as Dafny code, which obviously fails—turning a successful verification into a recorded failure.

In principle, you could fix this with more careful prompting. But our preferred fix is **backtracking through message history**, because every extra message stretches the context thinner and thinner which increases the chance that the agent starts to make grave mistakes (more on these in the fullness of the book). Instead of only looking at the final completion, we walk backwards through all assistant messages until we find one containing code:

```{literalinclude} ../../evals/src/evals/dafnybench/inspect_ai/utils.py
:language: python
:caption: Fixed extraction (v2) - backtracks through message history
:linenos:
:start-at: def extract_code_v2
:end-before: def extract_code(
```

This handles the celebration problem: if the current message has no code, we skip it and check the previous message. We eventually find the most recent code the agent actually generated.

You can switch between strategies using the `extraction_strategy` parameter in the task definition:

```
uv run agent dafnybench inspect --extraction-strategy v2
```

This pattern—searching backwards through conversation history—is useful whenever you have tool-calling loops where the final message might not contain the information you need. The verifier acts as a sensor providing feedback, and the agent's response to good news ("it worked!") can omit the actual artifact you're evaluating.

