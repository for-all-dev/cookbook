# The agent/solver

## The `pydantic-ai` Agent

Now, let's dive into the implementation of our Lean agent using `pydantic-ai`. The code is structured into several modules, each with a specific responsibility.

### The Agent (`agent.py`)

The core of our agent is in `agent.py`. We use `pydantic-ai`'s `Agent` class to create an agent that can use tools. The `@agent.tool` decorator makes it easy to define tools that the agent can call.

```{literalinclude} ../../evals/src/evals/fvapps/pydantic_ai/agent.py
:language: python
:caption: evals/src/evals/fvapps/pydantic_ai/agent.py
:start-at: "class AgentDeps"
:end-before: "def run_agent_on_sample"
```

The `create_fvapps_agent` function creates a `pydantic-ai` agent and defines a `verify_lean_tool` that the agent can use. The `AgentDeps` class is used to maintain state between tool calls, in this case, the number of attempts.

The `run_agent_on_sample` function then uses this agent to solve a single FVAPPS problem. It constructs a prompt with the problem description and the Lean code, and then calls `agent.run_sync`. `pydantic-ai` automatically handles the loop of calling the model, executing tools, and feeding the results back to the model.

```{literalinclude} ../../evals/src/evals/fvapps/pydantic_ai/agent.py
:language: python
:caption: evals/src/evals/fvapps/pydantic_ai/agent.py
:start-at: "def run_agent_on_sample"
```

### The Tool (`tools.py`)

The `verify_lean` function in `tools.py` is the heart of our evaluation. It takes a string of Lean code, creates a temporary Lean project, and runs `lake build` to check for errors.

```{literalinclude} ../../evals/src/evals/fvapps/pydantic_ai/tools.py
:language: python
:caption: evals/src/evals/fvapps/pydantic_ai/tools.py
:start-at: "def verify_lean"
```

This function is a good example of how to integrate a command-line tool into an agent. It handles creating the necessary files, running the tool, and parsing the output to determine success or failure.

### The Prompt (`prompt.py`)

The system prompt in `prompt.py` is crucial for guiding the model. It explains the task, the format of the expected output, and how to use the `verify_lean` tool.

```{literalinclude} ../../evals/src/evals/fvapps/pydantic_ai/prompt.py
:language: python
:caption: evals/src/evals/fvapps/pydantic_ai/prompt.py
```

### Data and Types (`types.py` and `dataset.py`)

We use Pydantic models in `types.py` to define the structure of our data. This helps with type checking and makes the code easier to read and maintain.

```{literalinclude} ../../evals/src/evals/fvapps/pydantic_ai/types.py
:language: python
:caption: evals/src/evals/fvapps/pydantic_ai/types.py
:start-at: "class FVAPPSSample"
```

The `load_fvapps_dataset` function in `dataset.py` loads the data from Hugging Face and converts it into a list of `FVAPPSSample` objects.

```{literalinclude} ../../evals/src/evals/fvapps/pydantic_ai/dataset.py
:language: python
:caption: evals/src/evals/fvapps/pydantic_ai/dataset.py
```

### The Main Evaluation Loop (`__init__.py`)

The `run_fvapps_eval` function in `__init__.py` ties everything together. It loads the dataset, iterates through the samples, calls `run_agent_on_sample` for each one, and then aggregates the results.

```{literalinclude} ../../evals/src/evals/fvapps/pydantic_ai/__init__.py
:language: python
:caption: evals/src/evals/fvapps/pydantic_ai/__init__.py
:start-at: "def run_fvapps_eval"
```

### Utilities (`utils.py`)

Finally, `utils.py` contains helper functions for extracting code from the model's output and categorizing Lean errors.

```{literalinclude} ../../evals/src/evals/fvapps/pydantic_ai/utils.py
:language: python
:caption: evals/src/evals/fvapps/pydantic_ai/utils.py
```

This walkthrough shows how you can use `pydantic-ai` to quickly build a powerful agent for a complex task like formal verification. The library handles the agent loop, leaving you to focus on the core logic of your tools and prompts.
