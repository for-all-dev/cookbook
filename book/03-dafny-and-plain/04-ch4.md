# State Management via Message History

As the agent inserts hints into the Dafny code, the code itself changes. This means we need a way to keep track of the current state of the code. ## TODO: audit the prose to make sure its not too LLMy

One way to do this is to maintain a separate state object that gets updated on each turn. But our plain Python agent uses a different approach: it uses the message history as the single source of truth.

We use a special marker, `=== CURRENT_CODE_STATE ===`, to indicate the current state of the code in the message history. The `get_code_state` function backtracks through the messages to find the most recent code state.

```{literalinclude} ../../evals/src/evals/dafnybench/plain/agent.py
:language: python
:caption: The get_code_state function
:start-at: "def get_code_state"
:end-before: "def update_code_state"
```

The `update_code_state` function appends the new code state to the message history.

```{literalinclude} ../../evals/src/evals/dafnybench/plain/agent.py
:language: python
:caption: The update_code_state function
:start-at: "def update_code_state"
:end-before: "class DafnyBenchAgent"
```

This approach has the advantage of keeping all the state in one place. It also makes it easy to debug the agent, since you can just look at the message history to see how the code has evolved over time.

However, it also has a subtle implication for how the agent uses tools. Because the state update happens after the tool results are appended to the message history, any tool calls made in the same turn will not see the updated state. This means that if the agent wants to make multiple, cumulative changes to the code, it needs to call `verify_dafny` or wait for the next iteration between each change. This is a deliberate design choice that forces the agent to be more methodical in its approach.